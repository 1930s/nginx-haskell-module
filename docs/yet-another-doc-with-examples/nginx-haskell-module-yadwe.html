<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Nginx Haskell module (yet another doc with examples)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="./pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Nginx Haskell module<br />
(yet another doc with examples)</h1>
</header>
<h1 id="why-bother">Why bother?</h1>
<p>The <a href="https://github.com/lyokha/nginx-haskell-module"><em>nginx-haskell-module</em></a> allows for running in Nginx synchronous and asynchronous tasks and content handlers written in Haskell.</p>
<h1 id="synchronous-tasks">Synchronous tasks</h1>
<p>Synchronous tasks are mostly <em>pure</em> Haskell functions of various types. To make them available in Nginx configuration files, they must be exported with special declarations named <em>exporters</em>. Below is a table of <em>type/exporter</em> correspondence for all available synchronous handlers.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Exporter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>String -&gt; String</code></td>
<td style="text-align: left;"><code>ngxExportSS</code> (<code>NGX_EXPORT_S_S</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String -&gt; String -&gt; String</code></td>
<td style="text-align: left;"><code>ngxExportSSS</code> (<code>NGX_EXPORT_S_SS</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String -&gt; Boolean</code></td>
<td style="text-align: left;"><code>ngxExportBS</code> (<code>NGX_EXPORT_B_S</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String -&gt; String -&gt; Boolean</code></td>
<td style="text-align: left;"><code>ngxExportBSS</code> (<code>NGX_EXPORT_B_SS</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>[String] -&gt; String</code></td>
<td style="text-align: left;"><code>ngxExportSLS</code> (<code>NGX_EXPORT_S_LS</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[String] -&gt; Boolean</code></td>
<td style="text-align: left;"><code>ngxExportBLS</code> (<code>NGX_EXPORT_B_LS</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; L.ByteString</code></td>
<td style="text-align: left;"><code>ngxExportYY</code> (<code>NGX_EXPORT_Y_Y</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ByteString -&gt; Boolean</code></td>
<td style="text-align: left;"><code>ngxExportBY</code> (<code>NGX_EXPORT_B_Y</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; IO L.ByteString</code></td>
<td style="text-align: left;"><code>ngxExportIOYY</code> (<code>NGX_EXPORT_IOY_Y</code>)</td>
</tr>
</tbody>
</table>
<p>All synchronous handlers may accept <em>strings</em> (one or two), a <em>list of strings</em>, or a <em>strict bytestring</em>, and return a <em>string</em>, a <em>boolean</em> or a <em>lazy bytestring</em>. The last handler from the table is <em>impure</em> or <em>effectful</em>, and it returns a <em>lazy bytestring</em> wrapped in <em>IO Monad</em>.</p>
<p>There are two kinds of exporters which differ only in their implementations. The first kind — <em>camel-cased</em> exporters — is implemented by means of <em>Template Haskell</em>, the other kind — exporters in braces, as they are shown in the table — is implemented using <em>CPP macros</em>. Both of them provide <em>FFI</em> declarations for functions they export, but the camel-cased exporters are available only from a separate Haskell module <a href="http://hackage.haskell.org/package/ngx-export"><em>ngx-export</em></a>, which can be downloaded and installed by <em>cabal</em>, whereas the CPP exporters are implemented inside the <em>nginx-haskell-module</em> in so-called <em>standalone</em> approach, where custom Haskell declarations get wrapped inside common Haskell code.</p>
<h2 id="examples">Examples</h2>
<p>In the examples we will use <em>modular</em> approach with <em>camel-cased</em> exporters.</p>
<p><strong>File test.hs</strong></p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #870087;">{-# LANGUAGE TemplateHaskell #-}</span>

<span style="color: #005F87;">module</span> <span style="color: #000000;">NgxHaskellUserRuntime</span> <span style="color: #005F87;">where</span>

<span style="color: #008787;">import</span>           <span style="color: #000000;">NgxExport</span>
<span style="color: #008787;">import</span> <span style="color: #008787;">qualified</span> <span style="color: #000000;">Data.Char</span> <span style="color: #008787;">as</span> <span style="color: #000000;">C</span>

<span style="color: #008700;">toUpper</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">String</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">String</span>
<span style="color: #008700;">toUpper</span> <span style="color: #005FAF;">=</span> <span style="color: #008700;">map</span> <span style="color: #005F87;">C</span><span style="color: #005FAF;">.</span><span style="color: #000000;">toUpper</span>
<span style="color: #008787;">ngxExportSS</span><span style="color: #000000;"> '</span><span style="color: #000000;">toUpper</span>

<span style="color: #008787;">ngxExportSS</span><span style="color: #000000;"> '</span><span style="color: #008700;">reverse</span>

<span style="color: #008700;">isInList</span> <span style="color: #005FAF;">::</span> <span style="color: #870087;">[</span><span style="color: #005F87;">String</span><span style="color: #870087;">]</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">Bool</span>
<span style="color: #008700;">isInList</span> <span style="color: #870087;">[]</span> <span style="color: #005FAF;">=</span> <span style="color: #AF5F00;">False</span>
<span style="color: #008700;">isInList</span> <span style="color: #870087;">(</span><span style="color: #000000;">x</span> <span style="color: #005FAF;">:</span> <span style="color: #000000;">xs</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">=</span> <span style="color: #000000;">x</span> <span style="color: #005FAF;">`elem`</span> <span style="color: #000000;">xs</span>
<span style="color: #008787;">ngxExportBLS</span><span style="color: #000000;"> '</span><span style="color: #000000;">isInList</span>
</pre>

<p>In this module we declared three synchronous handlers: <em>toUpper</em>, <em>reverse</em>, and <em>isInList</em>. Handler <em>reverse</em> exports existing and well-known Haskell function <em>reverse</em> which reverses lists. Let’s compile <em>test.hs</em> and move the library to a directory, from where we will load this.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">ghc -O2 -dynamic -shared -fPIC -L$(ghc --print-libdir)/rts -lHSrts-ghc$(ghc --numeric-version) test.hs -o test.so</span>
<span style="color: #808080;">[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )</span>
<span style="color: #808080;">Linking test.so ...</span>
<span style="color: #005FAF;">cp -i test.so /var/lib/nginx/</span>
</pre>

<p><strong>File test.conf</strong></p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #008700;">user</span><span style="color: #000000;">                    nginx;</span>
<span style="color: #008700;">worker_processes</span><span style="color: #000000;">        4;</span>

<span style="color: #005FAF;">events</span><span style="color: #000000;"> {</span>
    <span style="color: #008700;">worker_connections</span><span style="color: #000000;">  1024;</span>
<span style="color: #000000;">}</span>

<span style="color: #005FAF;">http</span><span style="color: #000000;"> {</span>
    <span style="color: #008700;">default_type</span><span style="color: #000000;">        application/octet-stream;</span>
    <span style="color: #008700;">sendfile</span>            <span style="color: #AF5F00;">on</span><span style="color: #000000;">;</span>

<span style="color: #000000;">    haskell load /var/lib/nginx/test.so;</span>

    <span style="color: #005FAF;">server</span><span style="color: #000000;"> {</span>
        <span style="color: #005F87;">listen</span><span style="color: #000000;">          8010;</span>
        <span style="color: #005F87;">server_name</span><span style="color: #000000;">     main;</span>

        <span style="color: #005FAF;">location</span><span style="color: #000000;"> / {</span>
<span style="color: #000000;">            haskell_run toUpper </span><span style="color: #008700;">$hs_upper</span> <span style="color: #008700;">$arg_u</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_run reverse </span><span style="color: #008700;">$hs_reverse</span> <span style="color: #008700;">$arg_r</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_run isInList </span><span style="color: #008700;">$hs_isInList</span> <span style="color: #008700;">$arg_a</span> <span style="color: #008700;">$arg_b</span> <span style="color: #008700;">$arg_c</span> <span style="color: #008700;">$arg_d</span><span style="color: #000000;">;</span>
            <span style="color: #870087;">echo</span> <span style="color: #AF5F00;">&quot;toUpper </span><span style="color: #008787;">$arg_u</span><span style="color: #AF5F00;"> = </span><span style="color: #008787;">$hs_upper</span><span style="color: #AF5F00;">&quot;</span><span style="color: #000000;">;</span>
            <span style="color: #870087;">echo</span> <span style="color: #AF5F00;">&quot;reverse </span><span style="color: #008787;">$arg_r</span><span style="color: #AF5F00;"> = </span><span style="color: #008787;">$hs_reverse</span><span style="color: #AF5F00;">&quot;</span><span style="color: #000000;">;</span>
            <span style="color: #870087;">echo</span> <span style="color: #AF5F00;">&quot;</span><span style="color: #008787;">$arg_a</span><span style="color: #AF5F00;"> `isInList` [</span><span style="color: #008787;">$arg_b</span><span style="color: #AF5F00;">, </span><span style="color: #008787;">$arg_c</span><span style="color: #AF5F00;">, </span><span style="color: #008787;">$arg_d</span><span style="color: #AF5F00;">] = </span><span style="color: #008787;">$hs_isInList</span><span style="color: #AF5F00;">&quot;</span><span style="color: #000000;">;</span>
<span style="color: #000000;">        }</span>
<span style="color: #000000;">    }</span>
<span style="color: #000000;">}</span>
</pre>

<p>Library <em>test.so</em> gets loaded by Nginx directive <em>haskell load</em>. All synchronous handlers run from directive <em>haskell_run</em>. The first argument of the directive is a name of a Haskell handler exported from the loaded library <em>test.so</em>, the second argument is an Nginx variable where the handler will put the result of its computation, the rest arguments are passed to the Haskell handler as parameters. Directive <em>haskell_run</em> has <em>lazy</em> semantics in the sense that it runs its handler only when the result is needed in a content handler or rewrite directives.</p>
<p>Let’s test the configuration with <em>curl</em>.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">curl 'http://127.0.0.1:8010/?u=hello&amp;r=world&amp;a=1&amp;b=10&amp;c=1'</span>
<span style="color: #808080;">toUpper hello = HELLO</span>
<span style="color: #808080;">reverse world = dlrow</span>
<span style="color: #808080;">1 `isInList` [10, 1, ] = 1</span>
</pre>

<h1 id="synchronous-content-handlers">Synchronous content handlers</h1>
<p>There are three types of exporters for synchronous content handlers.</p>
<table>
<colgroup>
<col style="width: 57%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Exporter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; (L.ByteString, ByteString, Int)</code></td>
<td style="text-align: left;"><code>ngxExportHandler</code> (<code>NGX_EXPORT_HANDLER</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ByteString -&gt; L.ByteString</code></td>
<td style="text-align: left;"><code>ngxExportDefHandler</code> (<code>NGX_EXPORT_DEF_HANDLER</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; (ByteString, ByteString, Int)</code></td>
<td style="text-align: left;"><code>ngxExportUnsafeHandler</code> (<code>NGX_EXPORT_UNSAFE_HANDLER</code>)</td>
</tr>
</tbody>
</table>
<p>All content handlers are <em>pure</em> Haskell functions, as well as the most of other synchronous handlers. The <em>normal</em> content handler returns a <em>3-tuple</em> <em>(response-body, content-type, HTTP-status)</em>. The response body consists of a number of chunks packed in a <em>lazy bytestring</em>, the content type is a <em>strict bytestring</em> such as <em>text/html</em>. The <em>default</em> handler defaults the content type to <em>text/plain</em> and the HTTP status to <em>200</em>, thus returning only chunks of the response body. The <em>unsafe</em> handler returns a <em>3-tuple</em> with a single-chunked response body, the content type and the status, but the both bytestring parameters are supposed to be taken from static data, which must not be cleaned up after request termination.</p>
<p><em>Normal</em> and <em>default</em> content handlers can be declared with two directives: <em>haskell_content</em> and <em>haskell_static_content</em>. The second directive runs its handler only once, when the first request comes, and returns the same response on further requests. The <em>unsafe</em> handler is declared with directive <em>haskell_unsafe_content</em>.</p>
<h2 id="an-example">An example</h2>
<p>Let’s replace Nginx directive <em>echo</em> with our own default content handler <em>echo</em>. Add in <em>test.hs</em>,</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #008787;">import</span>           <span style="color: #000000;">Data.ByteString</span> <span style="color: #000000;">(</span><span style="color: #005F87;">ByteString</span><span style="color: #000000;">)</span>
<span style="color: #008787;">import</span> <span style="color: #008787;">qualified</span> <span style="color: #000000;">Data.ByteString.Lazy</span> <span style="color: #008787;">as</span> <span style="color: #000000;">L</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008700;">echo</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">echo</span> <span style="color: #005FAF;">=</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">fromStrict</span>
<span style="color: #008787;">ngxExportDefHandler</span><span style="color: #000000;"> '</span><span style="color: #000000;">echo</span>
</pre>

<p>compile it and put <em>test.so</em> into <em>/var/lib/nginx/</em>. Add new location <em>/ch</em> into <em>test.conf</em>,</p>
<pre style="overflow-x: auto; background: #FFE">
        <span style="color: #005FAF;">location</span><span style="color: #000000;"> /ch {</span>
<span style="color: #000000;">            haskell_run toUpper </span><span style="color: #008700;">$hs_upper</span> <span style="color: #008700;">$arg_u</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_run reverse </span><span style="color: #008700;">$hs_reverse</span> <span style="color: #008700;">$arg_r</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_run isInList </span><span style="color: #008700;">$hs_isInList</span> <span style="color: #008700;">$arg_a</span> <span style="color: #008700;">$arg_b</span> <span style="color: #008700;">$arg_c</span> <span style="color: #008700;">$arg_d</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_content </span><span style="color: #870087;">echo</span>
<span style="color: #000000;">&quot;toUpper </span><span style="color: #008700;">$arg_u</span><span style="color: #000000;"> = </span><span style="color: #008700;">$hs_upper</span>
<span style="color: #000000;">reverse </span><span style="color: #008700;">$arg_r</span><span style="color: #000000;"> = </span><span style="color: #008700;">$hs_reverse</span>
<span style="color: #008700;">$arg_a</span><span style="color: #000000;"> `isInList` [</span><span style="color: #008700;">$arg_b</span><span style="color: #000000;">, </span><span style="color: #008700;">$arg_c</span><span style="color: #000000;">, </span><span style="color: #008700;">$arg_d</span><span style="color: #000000;">] = </span><span style="color: #008700;">$hs_isInList</span>
<span style="color: #000000;">&quot;;</span>
<span style="color: #000000;">        }</span>
</pre>

<p>and test again.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">curl 'http://127.0.0.1:8010/ch?u=content&amp;r=handler&amp;a=needle&amp;b=needle&amp;c=in&amp;d=stack'</span>
<span style="color: #808080;">toUpper content = CONTENT</span>
<span style="color: #808080;">reverse handler = reldnah</span>
<span style="color: #808080;">needle `isInList` [needle, in, stack] = 1</span>
</pre>

<h1 id="asynchronous-tasks-and-request-body-handlers">Asynchronous tasks and request body handlers</h1>
<p>There are only two types of Haskell handlers for per-request asynchronous tasks: the asynchronous handler and the asynchronous request body handler.</p>
<table>
<colgroup>
<col style="width: 57%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Exporter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; IO L.ByteString</code></td>
<td style="text-align: left;"><code>ngxExportAsyncIOYY</code> (<code>NGX_EXPORT_ASYNC_IOY_Y</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>L.ByteString -&gt; ByteString -&gt; IO L.ByteString</code></td>
<td style="text-align: left;"><code>ngxExportAsyncOnReqBody</code> (<code>NGX_EXPORT_ASYNC_ON_REQ_BODY</code>)</td>
</tr>
</tbody>
</table>
<p>Normal asynchronous handler accepts a strict bytestring and returns a lazy bytestring. Its type exactly corresponds to that of handlers exported with <em>ngxExportIOYY</em>. Request body handlers require the request body chunks in their first parameter.</p>
<p>Unlike synchronous handlers, asynchronous per-request handlers are <em>eager</em>. This means that they will always run when declared in a location, no matter whether their results are going to be used in the response and rewrite directives, or not. The asynchronous handlers run in an early <em>rewrite phase</em> (before rewrite directives), and in a late rewrite phase (after rewrite directives, if in the final location there are more asynchronous tasks declared). It is possible to declare many asynchronous tasks in a single location: in this case they are spawned one by one in order of their declarations, which lets using results of early tasks in inputs of later task.</p>
<p>Asynchronous tasks are bound to the Nginx event loop by means of <em>eventfd</em> (or POSIX <em>pipes</em> if eventfd was not available on the platform when Nginx was being compiled). When the rewrite phase handler of this module spawns an asynchronous task, it opens an eventfd, then registers it in the event loop, and passes it to the Haskell handler. As soon as the Haskell handler finishes the task and pokes the result into buffers, it writes into the eventfd, thus informing the Nginx part that the task has been finished. Then Nginx gets back to the module’s rewrite phase handler, and it spawns the next asynchronous task, or returns (when there are no more tasks), moving request processing to the next stage.</p>
<h2 id="an-example-1">An example</h2>
<p>Let’s add two asynchronous handlers into <em>test.hs</em>: one for extracting a field from POST data, and the other for delaying response for a given number of seconds.</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #008787;">import</span> <span style="color: #008787;">qualified</span> <span style="color: #000000;">Data.ByteString.Char8</span> <span style="color: #008787;">as</span> <span style="color: #000000;">C8</span>
<span style="color: #008787;">import</span> <span style="color: #008787;">qualified</span> <span style="color: #000000;">Data.ByteString.Lazy.Char8</span> <span style="color: #008787;">as</span> <span style="color: #000000;">C8L</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Control.Concurrent</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Safe</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008700;">reqFld</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">reqFld</span> <span style="color: #000000;">a</span> <span style="color: #000000;">fld</span> <span style="color: #005FAF;">=</span> <span style="color: #008700;">return</span> <span style="color: #005FAF;">$</span> <span style="color: #008700;">maybe</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">empty</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #008700;">tail</span> <span style="color: #005FAF;">$</span>
    <span style="color: #008700;">lookup</span> <span style="color: #870087;">(</span><span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">fromStrict</span> <span style="color: #000000;">fld</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">$</span> <span style="color: #008700;">map</span> <span style="color: #870087;">(</span><span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #008700;">break</span> <span style="color: #870087;">(</span><span style="color: #005FAF;">==</span> <span style="color: #AF5F00;">'='</span><span style="color: #870087;">))</span> <span style="color: #005FAF;">$</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">split</span> <span style="color: #AF5F00;">'&amp;'</span> <span style="color: #000000;">a</span>
<span style="color: #008787;">ngxExportAsyncOnReqBody</span><span style="color: #000000;"> '</span><span style="color: #000000;">reqFld</span>

<span style="color: #008700;">delay</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">delay</span> <span style="color: #000000;">v</span> <span style="color: #005FAF;">=</span> <span style="color: #005FAF;">do</span>
    <span style="color: #005FAF;">let</span> <span style="color: #000000;">t</span> <span style="color: #005FAF;">=</span> <span style="color: #000000;">readDef</span> <span style="color: #AF5F00;">0</span> <span style="color: #005FAF;">$</span> <span style="color: #005F87;">C8</span><span style="color: #005FAF;">.</span><span style="color: #000000;">unpack</span> <span style="color: #000000;">v</span>
    <span style="color: #000000;">threadDelay</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">t</span> <span style="color: #005FAF;">*</span> <span style="color: #AF5F00;">1000000</span>
    <span style="color: #008700;">return</span> <span style="color: #005FAF;">$</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">pack</span> <span style="color: #005FAF;">$</span> <span style="color: #008700;">show</span> <span style="color: #000000;">t</span>
<span style="color: #008787;">ngxExportAsyncIOYY</span><span style="color: #000000;"> '</span><span style="color: #000000;">delay</span>
</pre>

<p>This code must be linked with <em>threaded</em> Haskell RTS this time!</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">ghc -O2 -dynamic -shared -fPIC -L$(ghc --print-libdir)/rts -lHSrts_thr-ghc$(ghc --numeric-version) test.hs -o test.so</span>
<span style="color: #808080;">[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )</span>
<span style="color: #808080;">Linking test.so ...</span>
<span style="color: #005FAF;">cp -i test.so /var/lib/nginx/</span>
</pre>

<p>Let’s make location <em>/timer</em>, where we will read how many seconds to wait from the POST field <em>timer</em>, and then wait them until returning the response.</p>
<pre style="overflow-x: auto; background: #FFE">
        <span style="color: #005FAF;">location</span><span style="color: #000000;"> /timer {</span>
<span style="color: #000000;">            haskell_run_async_on_request_body reqFld </span><span style="color: #008700;">$hs_timeout</span><span style="color: #000000;"> timer;</span>
<span style="color: #000000;">            haskell_run_async delay </span><span style="color: #008700;">$hs_waited</span> <span style="color: #008700;">$hs_timeout</span><span style="color: #000000;">;</span>
            <span style="color: #870087;">echo</span> <span style="color: #AF5F00;">&quot;Waited </span><span style="color: #008787;">$hs_waited</span><span style="color: #AF5F00;"> sec&quot;</span><span style="color: #000000;">;</span>
<span style="color: #000000;">        }</span>
</pre>

<p>Run curl tests.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">curl -d 'timer=3' 'http://127.0.0.1:8010/timer'</span>
<span style="color: #808080;">Waited 3 sec</span>
<span style="color: #005FAF;">curl -d 'timer=bad' 'http://127.0.0.1:8010/timer'</span>
<span style="color: #808080;">Waited 0 sec</span>
</pre>

<h1 id="asynchronous-content-handler">Asynchronous content handler</h1>
<p>There is a special type of <em>impure</em> content handlers which allows for effectful code. The type corresponds to that of the <em>normal</em> content handler, except the result is wrapped in <em>IO Monad</em>.</p>
<table>
<colgroup>
<col style="width: 62%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Exporter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; IO (L.ByteString, ByteString, Int)</code></td>
<td style="text-align: left;"><code>ngxExportAsyncHandler</code> (<code>NGX_EXPORT_ASYNC_HANDLER</code>)</td>
</tr>
</tbody>
</table>
<p>Such handlers are declared with directive <em>haskell_async_content</em>.</p>
<p>It’s easy to emulate effects in a synchronous content handler by combining the latter with an asynchronous task like in the following example.</p>
<pre style="overflow-x: auto; background: #FFE">
        <span style="color: #005FAF;">location</span><span style="color: #000000;"> /async_content {</span>
<span style="color: #000000;">            haskell_run_async getUrl </span><span style="color: #008700;">$hs_async_httpbin</span> <span style="color: #AF5F00;">&quot;http://httpbin.org&quot;</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_content </span><span style="color: #870087;">echo</span> <span style="color: #008700;">$hs_async_httpbin</span><span style="color: #000000;">;</span>
<span style="color: #000000;">        }</span>
</pre>

<p>Here <em>getUrl</em> is an asynchronous Haskell handler that returns content of an HTTP page. This approach has at least two deficiencies related to performance and memory usage. The content may be huge and chunked, and its chunks could have been naturally used in the content handler. But they won’t, because here they get collected by directive <em>haskell_run_async</em> into a single chunk, and then passed to the content handler <em>echo</em>. The other problem deals with <em>eagerness</em> of asynchronous tasks. Imagine that we put in the location a rewrite to another location: handler <em>getUrl</em> will run before redirection, but variable <em>hs_async_httpbin</em> will never be used because we’ll get out from the current location.</p>
<p>The asynchronous task runs in a late <em>access phase</em>, and the lazy bytestring — the contents — gets used in the content handler as is, with all of its originally computed chunks.</p>
<h2 id="an-example-2">An example</h2>
<p>Let’s rewrite our <em>timer</em> example using <em>haskell_async_content</em>.</p>
<p><strong>File test.hs</strong> (<em>additions</em>)</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #870087;">{-# LANGUAGE TupleSections #-}</span>
<span style="color: #870087;">{-# LANGUAGE MagicHash #-}</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008787;">import</span>           <span style="color: #000000;">Data.ByteString.Unsafe</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Data.ByteString.Internal</span> <span style="color: #000000;">(</span><span style="color: #008700;">accursedUnutterablePerformIO</span><span style="color: #000000;">)</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008700;">delayContent</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #870087;">(</span><span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span><span style="color: #870087;">,</span> <span style="color: #005F87;">ByteString</span><span style="color: #870087;">,</span> <span style="color: #005F87;">Int</span><span style="color: #870087;">)</span>
<span style="color: #008700;">delayContent</span> <span style="color: #000000;">v</span> <span style="color: #005FAF;">=</span> <span style="color: #005FAF;">do</span>
    <span style="color: #000000;">v</span><span style="color: #000000;">' </span><span style="color: #005FAF;">&lt;-</span> <span style="color: #000000;">delay</span> <span style="color: #000000;">v</span>
    <span style="color: #008700;">return</span> <span style="color: #005FAF;">$</span> <span style="color: #870087;">(,</span> <span style="color: #000000;">packLiteral</span> <span style="color: #AF5F00;">10</span> <span style="color: #AF5F00;">&quot;text/plain&quot;</span><span style="color: #005FAF;">#</span><span style="color: #870087;">,</span> <span style="color: #AF5F00;">200</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">$</span>
        <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #008700;">concat</span> <span style="color: #870087;">[</span><span style="color: #AF5F00;">&quot;Waited &quot;</span><span style="color: #870087;">,</span> <span style="color: #000000;">v</span><span style="color: #000000;">'</span><span style="color: #870087;">,</span> <span style="color: #AF5F00;">&quot; sec</span><span style="color: #870087;">\n</span><span style="color: #AF5F00;">&quot;</span><span style="color: #870087;">]</span>
    <span style="color: #005F87;">where</span> <span style="color: #000000;">packLiteral</span> <span style="color: #000000;">l</span> <span style="color: #000000;">s</span> <span style="color: #005FAF;">=</span>
              <span style="color: #000000;">accursedUnutterablePerformIO</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">unsafePackAddressLen</span> <span style="color: #000000;">l</span> <span style="color: #000000;">s</span>
<span style="color: #008787;">ngxExportAsyncHandler</span><span style="color: #000000;"> '</span><span style="color: #000000;">delayContent</span>
</pre>

<p>For the <em>content type</em> we used a static string <em>“text/plain”#</em> that ends with a <em>magic hash</em> merely to avoid <em>any</em> memory allocations.</p>
<p><strong>File test.conf</strong> (<em>additions</em>)</p>
<pre style="overflow-x: auto; background: #FFE">
        <span style="color: #005FAF;">location</span><span style="color: #000000;"> /timer/ch {</span>
<span style="color: #000000;">            haskell_run_async_on_request_body reqFld </span><span style="color: #008700;">$hs_timeout</span><span style="color: #000000;"> timer;</span>
<span style="color: #000000;">            haskell_async_content delayContent </span><span style="color: #008700;">$hs_timeout</span><span style="color: #000000;">;</span>
<span style="color: #000000;">        }</span>
</pre>

<p>Run curl tests.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">curl -d 'timer=3' 'http://127.0.0.1:8010/timer/ch'</span>
<span style="color: #808080;">Waited 3 sec</span>
<span style="color: #005FAF;">curl 'http://127.0.0.1:8010/timer/ch'</span>
<span style="color: #808080;">Waited 0 sec</span>
</pre>

<h1 id="asynchronous-services">Asynchronous services</h1>
<p>Asynchronous tasks run in a request context, whereas asynchronous services run in a worker context. They start when the module gets initialized in a worker, and stop when a worker terminates. They are useful for gathering rarely changed data shared in many requests.</p>
<p>There is only one type of asynchronous services exporters.</p>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Exporter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ByteString -&gt; Bool -&gt; IO L.ByteString</code></td>
<td style="text-align: left;"><code>ngxExportServiceIOYY</code> (<code>NGX_EXPORT_SERVICE_IOY_Y</code>)</td>
</tr>
</tbody>
</table>
<p>It accepts a strict bytestring and a boolean value, and returns a lazy bytestring (chunks of data). If the boolean argument is <em>True</em> then this service has never been called before in this worker process: this can be used to initialize some global data needed by the service on the first call.</p>
<p>Services are declared with Nginx directive <em>haskell_run_service</em>. As far as they are not bound to requests, the directive is only available on the <em>http</em> configuration level.</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #000000;">    haskell_run_service getUrlService </span><span style="color: #008700;">$hs_service_httpbin</span> <span style="color: #AF5F00;">&quot;http://httpbin.org&quot;</span><span style="color: #000000;">;</span>
</pre>

<p>The first argument is, as ever, the name of a Haskell handler, the second — a variable where the service result will be put, and the third argument is data passed to the handler <em>getUrlService</em> in its first parameter. Notice that the third argument cannot contain variables because variable handlers in Nginx are only available in a request context, hence this argument may only be a static string.</p>
<p>Asynchronous services are bound to the Nginx event loop in the same way as asynchronous tasks. When a service finishes its computation, it pokes data into buffers and writes into eventfd (or a pipe’s write end). Then the event handler immediately restarts the service with the boolean argument equal to <em>False</em>. This is responsibility of the author of a service handler to avoid dry runs and make sure that it is called not so often in a row. For example, if a service polls periodically, then it must delay for this time itself like in the following example.</p>
<h2 id="an-example-3">An example</h2>
<p>Let’s retrieve content of a specific URL, say <em>httpbin.org</em>, in background. Data will update every 20 seconds.</p>
<p><strong>File test.hs</strong> (<em>additions</em>)</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #008787;">import</span>           <span style="color: #000000;">Network.HTTP.Client</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Control.Exception</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">System.IO.Unsafe</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Control.Monad</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008700;">httpManager</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">Manager</span>
<span style="color: #008700;">httpManager</span> <span style="color: #005FAF;">=</span> <span style="color: #000000;">unsafePerformIO</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">newManager</span> <span style="color: #000000;">defaultManagerSettings</span>
<span style="color: #870087;">{-# NOINLINE httpManager #-}</span>

<span style="color: #008700;">getUrl</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">getUrl</span> <span style="color: #000000;">url</span> <span style="color: #005FAF;">=</span> <span style="color: #000000;">catchHttpException</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">getResponse</span> <span style="color: #000000;">url</span> <span style="color: #005FAF;">$</span> <span style="color: #008700;">flip</span> <span style="color: #000000;">httpLbs</span> <span style="color: #000000;">httpManager</span>
    <span style="color: #005F87;">where</span> <span style="color: #000000;">getResponse</span> <span style="color: #000000;">u</span> <span style="color: #005FAF;">=</span> <span style="color: #008700;">fmap</span> <span style="color: #000000;">responseBody</span> <span style="color: #005FAF;">.</span> <span style="color: #870087;">(</span><span style="color: #000000;">parseRequest</span> <span style="color: #870087;">(</span><span style="color: #005F87;">C8</span><span style="color: #005FAF;">.</span><span style="color: #000000;">unpack</span> <span style="color: #000000;">u</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">&gt;&gt;=</span><span style="color: #870087;">)</span>

<span style="color: #008700;">catchHttpException</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">catchHttpException</span> <span style="color: #005FAF;">=</span> <span style="color: #870087;">(</span><span style="color: #005FAF;">`catch`</span> <span style="color: #005FAF;">\</span><span style="color: #000000;">e</span> <span style="color: #005FAF;">-&gt;</span>
        <span style="color: #008700;">return</span> <span style="color: #005FAF;">$</span> <span style="color: #005F87;">C8L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">pack</span> <span style="color: #005FAF;">$</span> <span style="color: #AF5F00;">&quot;HTTP EXCEPTION: &quot;</span> <span style="color: #005FAF;">++</span> <span style="color: #008700;">show</span> <span style="color: #870087;">(</span><span style="color: #000000;">e</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">HttpException</span><span style="color: #870087;">))</span>

<span style="color: #008700;">getUrlService</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">Bool</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">getUrlService</span> <span style="color: #000000;">url</span> <span style="color: #000000;">firstRun</span> <span style="color: #005FAF;">=</span> <span style="color: #005FAF;">do</span>
    <span style="color: #000000;">unless</span> <span style="color: #000000;">firstRun</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">threadDelay</span> <span style="color: #005FAF;">$</span> <span style="color: #AF5F00;">20</span> <span style="color: #005FAF;">*</span> <span style="color: #AF5F00;">1000000</span>
    <span style="color: #000000;">getUrl</span> <span style="color: #000000;">url</span>
<span style="color: #008787;">ngxExportServiceIOYY</span><span style="color: #000000;"> '</span><span style="color: #000000;">getUrlService</span>
</pre>

<p>The <em>httpManager</em> defines a global state, not to say a <em>variable</em>: this is an asynchronous HTTP client implemented in module <em>Network.HTTP.Client</em>. Pragma <em>NOINLINE</em> ensures that all functions will refer to the same client object, i.e. it will nowhere be inlined. Functions <em>getUrl</em> and <em>catchHttpException</em> are used in our service handler <em>getUrlService</em>. The handler waits 20 seconds on every run except the first, and then runs the HTTP client. All HTTP exceptions are caught by <em>catchHttpException</em>, others hit the handler on top of the custom Haskell code and get logged by Nginx.</p>
<p><strong>File test.conf</strong> (<em>additions</em>)</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #000000;">    haskell_run_service getUrlService </span><span style="color: #008700;">$hs_service_httpbin</span> <span style="color: #AF5F00;">&quot;http://httpbin.org&quot;</span><span style="color: #000000;">;</span>

<span style="color: #808080;">    # ...</span>

        <span style="color: #005FAF;">location</span><span style="color: #000000;"> /httpbin {</span>
            <span style="color: #870087;">echo</span> <span style="color: #008700;">$hs_service_httpbin</span><span style="color: #000000;">;</span>
<span style="color: #000000;">        }</span>
</pre>

<p>Run curl tests.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">curl 'http://127.0.0.1:8010/httpbin'</span>
<span style="color: #808080;">&lt;!DOCTYPE html&gt;</span>
<span style="color: #808080;">&lt;html&gt;</span>
<span style="color: #808080;">&lt;head&gt;</span>
<span style="color: #808080;">  &lt;meta http-equiv='content-type' value='text/html;charset=utf8'&gt;</span>
<span style="color: #808080;">  &lt;meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'&gt;</span>
<span style="color: #808080;">  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;</span>

<span style="color: #808080;">...</span>
</pre>

<p>This must run really fast because it shows data that has already been retrieved by the service, requests do not trigger any network activity with <em>httpbin.org</em> by themselves!</p>
<h2 id="termination-of-a-service">Termination of a service</h2>
<p>Services are killed on a worker’s exit with Haskell asynchronous exception <em>ThreadKilled</em>. Then the worker waits <em>synchronously</em> until all of its services’ threads exit, and calls <em>hs_exit()</em>. This scenario has two important implications.</p>
<ol type="1">
<li>The Haskell service handler may catch <em>ThreadKilled</em> on exit and make persistency actions such as writing files if they are needed.</li>
<li><em>Unsafe</em> <em>blocking</em> FFI calls must be avoided in service handlers as they may hang the Nginx worker, and it won’t exit. Using <em>interruptible</em> FFI fixes this problem.</li>
</ol>
<h1 id="shared-services">Shared services</h1>
<p>An asynchronous service may store its result in shared memory accessible from all worker processes. This is achieved with directive <em>haskell_service_var_in_shm</em>. For example, the following declaration (in <em>http</em> clause),</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #000000;">    haskell_service_var_in_shm httpbin 512k /tmp </span><span style="color: #008700;">$hs_service_httpbin</span><span style="color: #000000;">;</span>
</pre>

<p>makes service <em>getUrlService</em>, that stores its result in variable <em>hs_service_httpbin</em>, shared. The first argument of the directive — <em>httpbin</em> — is an identifier of a shared memory segment, <em>512k</em> is its maximum size, <em>/tmp</em> is a directory where <em>file locks</em> will be put (see below), and <em>$hs_service_httpbin</em> is the service variable.</p>
<p>Shared services are called <em>shared</em> not only because they store results in shared memory, but also because at any moment of the Nginx master lifetime there is only one worker that runs a specific service. When workers start, they race to acquire a <em>file lock</em> for a service, and if a worker wins the race, it holds the lock until it exits or dies. Other workers’ services of the same type wait until the lock is freed. The locks are implemented via POSIX <em>advisory</em> file locks, and so require a directory where they will be put. The directory must be <em>writable</em> to worker processes, and <em>/tmp</em> seems to be a good choice in general.</p>
<h2 id="update-variables">Update variables</h2>
<p>The active shared service put the value of the shared variable in a shared memory, services on other workers wait and do nothing else. Requests may come to any worker (with active or inactive services), fortunately the service result is shared and they can return it as is. But what if the result must be somehow interpreted by Haskell handlers before returning it in the response? Could the handlers just peek into the shared memory and do what they want with the shared data? Unfortunately, not: the shared memory is accessible for reading and writing only from the Nginx part!</p>
<p>Does it mean that we have only one option to let the Haskell part update its global state unavailable in inactive workers: passing values of shared variables into the Haskell part on every request? This would be extremely inefficient. Update variables is a trick to avoid this. They evaluate to the corresponding service variable’s value only when it changes in the shared memory since the last check in the current worker, and to an empty string otherwise. Every service variable has its update variable counterpart which name is built from the service variable’s name with prefix <em>_upd__</em>.</p>
<h3 id="an-example-4">An example</h3>
<p>Let’s extend our example with loading a page in background. We are still going to load <em>httpbin.org</em>, but this time let’s assume that we have another task, say extracting all links from the page and showing them in the response sorted. For that we could add a Haskell handler, say <em>sortLinks</em>, and pass to it all the page content on every request. But the page may appear huge, let’s extract all the links from it and put them into a global state using update variable <em>_upd__hs_service_httpbin</em>. In this case function <em>sortLinks</em> must be impure, as it must be able to read from the global state.</p>
<p><strong>File test.hs</strong> (<em>additions</em>)</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #870087;">{-# LANGUAGE OverloadedStrings #-}</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008787;">import</span>           <span style="color: #000000;">Data.IORef</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Text.Regex.PCRE.ByteString</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Text.Regex.Base.RegexLike</span>
<span style="color: #008787;">import</span> <span style="color: #008787;">qualified</span> <span style="color: #000000;">Data.Array</span> <span style="color: #008787;">as</span> <span style="color: #000000;">A</span>
<span style="color: #008787;">import</span>           <span style="color: #000000;">Data.List</span>

<span style="color: #808080;">-- ...</span>

<span style="color: #008700;">gHttpbinLinks</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">IORef</span> <span style="color: #870087;">[</span><span style="color: #005F87;">ByteString</span><span style="color: #870087;">]</span>
<span style="color: #008700;">gHttpbinLinks</span> <span style="color: #005FAF;">=</span> <span style="color: #000000;">unsafePerformIO</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">newIORef</span> <span style="color: #870087;">[]</span>
<span style="color: #870087;">{-# NOINLINE gHttpbinLinks #-}</span>

<span style="color: #008700;">grepLinks</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #870087;">[</span><span style="color: #005F87;">ByteString</span><span style="color: #870087;">]</span>
<span style="color: #008700;">grepLinks</span> <span style="color: #000000;">v</span> <span style="color: #005FAF;">=</span>
    <span style="color: #008700;">map</span> <span style="color: #870087;">(</span><span style="color: #008700;">fst</span> <span style="color: #005FAF;">.</span> <span style="color: #008700;">snd</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">.</span> <span style="color: #008700;">filter</span> <span style="color: #870087;">((</span><span style="color: #AF5F00;">1</span> <span style="color: #005FAF;">==</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">.</span> <span style="color: #008700;">fst</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">.</span> <span style="color: #008700;">concatMap</span> <span style="color: #005F87;">A</span><span style="color: #005FAF;">.</span><span style="color: #000000;">assocs</span> <span style="color: #005FAF;">.</span>
        <span style="color: #008700;">filter</span> <span style="color: #870087;">(</span><span style="color: #008700;">not</span> <span style="color: #005FAF;">.</span> <span style="color: #008700;">null</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">.</span> <span style="color: #008700;">concatMap</span> <span style="color: #870087;">(</span><span style="color: #000000;">matchAllText</span> <span style="color: #000000;">regex</span><span style="color: #870087;">)</span> <span style="color: #005FAF;">$</span>
            <span style="color: #005F87;">C8</span><span style="color: #005FAF;">.</span><span style="color: #000000;">split</span> <span style="color: #AF5F00;">'</span><span style="color: #870087;">\n</span><span style="color: #AF5F00;">'</span> <span style="color: #000000;">v</span>
    <span style="color: #005F87;">where</span> <span style="color: #000000;">regex</span> <span style="color: #005FAF;">=</span> <span style="color: #000000;">makeRegex</span> <span style="color: #005FAF;">$</span> <span style="color: #005F87;">C8</span><span style="color: #005FAF;">.</span><span style="color: #000000;">pack</span> <span style="color: #AF5F00;">&quot;a href=</span><span style="color: #870087;">\&quot;</span><span style="color: #AF5F00;">([^</span><span style="color: #870087;">\&quot;</span><span style="color: #AF5F00;">]+)</span><span style="color: #870087;">\&quot;</span><span style="color: #AF5F00;">&quot;</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">Regex</span>

<span style="color: #008700;">grepHttpbinLinks</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">grepHttpbinLinks</span> <span style="color: #AF5F00;">&quot;&quot;</span> <span style="color: #005FAF;">=</span> <span style="color: #008700;">return</span> <span style="color: #AF5F00;">&quot;&quot;</span>
<span style="color: #008700;">grepHttpbinLinks</span> <span style="color: #000000;">v</span>  <span style="color: #005FAF;">=</span> <span style="color: #005FAF;">do</span>
    <span style="color: #000000;">writeIORef</span> <span style="color: #000000;">gHttpbinLinks</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">grepLinks</span> <span style="color: #000000;">v</span>
    <span style="color: #008700;">return</span> <span style="color: #AF5F00;">&quot;&quot;</span>
<span style="color: #008787;">ngxExportIOYY</span><span style="color: #000000;"> '</span><span style="color: #000000;">grepHttpbinLinks</span>

<span style="color: #008700;">sortLinks</span> <span style="color: #005FAF;">::</span> <span style="color: #005F87;">ByteString</span> <span style="color: #005FAF;">-&gt;</span> <span style="color: #005F87;">IO</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #005F87;">ByteString</span>
<span style="color: #008700;">sortLinks</span> <span style="color: #AF5F00;">&quot;httpbin&quot;</span> <span style="color: #005FAF;">=</span> <span style="color: #005FAF;">do</span>
    <span style="color: #000000;">links</span> <span style="color: #005FAF;">&lt;-</span> <span style="color: #000000;">readIORef</span> <span style="color: #000000;">gHttpbinLinks</span>
    <span style="color: #008700;">return</span> <span style="color: #005FAF;">$</span> <span style="color: #005F87;">L</span><span style="color: #005FAF;">.</span><span style="color: #000000;">fromChunks</span> <span style="color: #005FAF;">$</span> <span style="color: #000000;">sort</span> <span style="color: #005FAF;">$</span> <span style="color: #008700;">map</span> <span style="color: #870087;">(</span><span style="color: #005FAF;">`C8.append`</span> <span style="color: #AF5F00;">&quot;</span><span style="color: #870087;">\n</span><span style="color: #AF5F00;">&quot;</span><span style="color: #870087;">)</span> <span style="color: #000000;">links</span>
<span style="color: #008700;">sortLinks</span> <span style="color: #870087;">_</span> <span style="color: #005FAF;">=</span> <span style="color: #008700;">return</span> <span style="color: #AF5F00;">&quot;&quot;</span>
<span style="color: #008787;">ngxExportIOYY</span><span style="color: #000000;"> '</span><span style="color: #000000;">sortLinks</span>
</pre>

<p>Here <em>gHttpbinLinks</em> is the global state, <em>grepHttpbinLinks</em> is a handler for update variable <em>_upd__hs_service_httpbin</em>, almost all the time it does nothing — just returns an empty string, but when the update variable becomes not empty, it updates the global state and returns an empty string again. Handler <em>sortLinks</em> is parameterized by data identifier: when it’s equal to <em>httpbin</em>, it reads the global state and returns it sorted, otherwise it returns an empty string.</p>
<p><strong>File test.conf</strong> (<em>additions</em>)</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #000000;">    haskell_service_var_in_shm httpbin 512k /tmp </span><span style="color: #008700;">$hs_service_httpbin</span><span style="color: #000000;">;</span>

<span style="color: #808080;">    # ...</span>

        <span style="color: #005FAF;">location</span><span style="color: #000000;"> /httpbin/sortlinks {</span>
<span style="color: #000000;">            haskell_run grepHttpbinLinks </span><span style="color: #008700;">$_upd_links_</span> <span style="color: #008700;">$_upd__hs_service_httpbin</span><span style="color: #000000;">;</span>
<span style="color: #000000;">            haskell_run sortLinks </span><span style="color: #008700;">$hs_links</span> <span style="color: #AF5F00;">&quot;${_upd_links_}httpbin&quot;</span><span style="color: #000000;">;</span>
            <span style="color: #870087;">echo</span> <span style="color: #008700;">$hs_links</span><span style="color: #000000;">;</span>
<span style="color: #000000;">        }</span>
</pre>

<p>We have to pass variable <em>_upd_links_</em> in <em>sortLinks</em> because this will trigger update in the worker by <em>grepHttpbinLinks</em>, otherwise update won’t run: remember that Nginx directives are lazy? On the other hand, <em>_upd_links_</em> is always empty and won’t mess up with the rest of the argument — value <em>httpbin</em>.</p>
<p>Run curl tests.</p>
<pre style="overflow-x: auto; border-style: none none none solid; border-color: #6DF; border-width: 10px; padding: 5px 10px">
<span style="color: #005FAF;">curl 'http://127.0.0.1:8010/httpbin/sortlinks'</span>
<span style="color: #808080;">/</span>
<span style="color: #808080;">/absolute-redirect/6</span>
<span style="color: #808080;">/anything</span>
<span style="color: #808080;">/basic-auth/user/passwd</span>
<span style="color: #808080;">/brotli</span>
<span style="color: #808080;">/bytes/1024</span>

<span style="color: #808080;">...</span>
</pre>

<h2 id="update-callbacks">Update callbacks</h2>
<p>There is a special type of single-shot services called update callbacks. They are declared like</p>
<pre style="overflow-x: auto; background: #FFE">
<span style="color: #000000;">    haskell_service_var_update_callback cb_httpbin </span><span style="color: #008700;">$hs_service_httpbin</span><span style="color: #000000;"> optional_value;</span>
</pre>

<p>Here <em>cb_httpbin</em> is a Haskell handler exported by <em>ngxExportServiceIOYY</em> as always. Variable <em>hs_service_httpbin</em> must be declared in directive <em>haskell_service_var_in_shm</em> (this matches our example). Argument <em>optional_value</em> is a string, it can be omitted in which case handler <em>cb_httpbin</em> gets an empty string as its first argument.</p>
<p>Update callbacks do not return results. They run from a worker that holds the active service on every change of the service variable, and shall be supposedly used to integrate with other Nginx modules by signaling specific Nginx locations via an HTTP client.</p>
<h2 id="shm-stats-variables">Shm stats variables</h2>
<p>Every service variable in shared memory has an auxiliary variable that provides basic stats in format <em>timestamp | size | changes | failures | failed</em>, where <em>timestamp</em> is a number of seconds elapsed from the beginning of the <em>UNIX epoch</em> till the last change of the variable’s value, <em>size</em> is the size of the variable in bytes, <em>changes</em> is a number of changes, and <em>failures</em> is a number of memory allocation failures since the last Nginx reload, the value of flag <em>failed</em> (<em>0</em> or <em>1</em>) denotes if the last attempt of memory allocation from the shared memory pool for a new value of the variable has failed. The name of the shm stats variable is built from the service variable’s name with prefix <em>_shm__</em>.</p>
<h1 id="efficiency-of-data-exchange-between-nginx-and-haskell-parts">Efficiency of data exchange between Nginx and Haskell parts</h1>
<p>Haskell handlers may accept strings (<code>String</code> or <code>[String]</code>) and <em>strict</em> bytestrings (<code>ByteString</code>), and return strings, <em>lazy</em> bytestrings and booleans. Input C-strings are marshaled into a <em>String</em> with <em>peekCStringLen</em> which has linear complexity <span class="math inline"><em>O</em>(<em>n</em>)</span>, output <em>Strings</em> are marshaled into C-strings with <em>newCStringLen</em> which is also <span class="math inline"><em>O</em>(<em>n</em>)</span>. The new C-strings get freed upon the request termination in the Nginx part.</p>
<p>The bytestring counterparts are much faster. Both input and output are <span class="math inline"><em>O</em>(1)</span>, using <em>unsafePackCStringLen</em> and a Haskell <em>stable pointer</em> to lazy bytestring buffers created inside Haskell handlers. If an output lazy bytestring has more than one chunk, a new single-chunked C-string will be created in variable and service handlers, but not in content handlers because the former use the chunks directly when constructing contents. Holding a stable pointer to a bytestring’s chunks on the Nginx part ensures that they won’t be garbage collected until the pointer gets freed. Stable pointers get freed upon the request termination for variable and content handlers, and before the next service iteration for service handlers.</p>
<p>Complex scenarios may require <em>typed exchange</em> between Haskell handlers and the Nginx part using <em>serialized</em> data types such as Haskell records. In this case <em>bytestring</em> flavors of the handlers would be the best choice. There are two well-known serialization mechanisms: <em>packing Show</em> / <em>unpacking Read</em> and <em>ToJSON</em> / <em>FromJSON</em> from Haskell package <em>aeson</em>. In practice, <em>Show</em> is basically faster than <em>ToJSON</em>, however in many cases <em>FromJSON</em> outperforms <em>Read</em>.</p>
<p>A variable handler of a shared service makes a copy of the variable’s value because shared data can be altered by any worker at any moment, and there is no safe way to hold a reference to a shared data without locking. In contrast, a variable handler of a normal per-worker service shares a reference to the value with the service. Obviously, this is still not safe. Imagine that some request gets a reference to a service value from the variable handler, then lasts some time and later uses this reference again: the reference could probably be freed by this time because the service could have altered its data since the beginning of the request. This catastrophic situation could have been fixed by using a copy of the service value in every request like in shared services, but this would unnecessarily hit performance, therefore requests share <em>counted references</em>, and as soon as the count reaches <em>0</em>, the service value gets freed.</p>
<h1 id="exceptions-in-haskell-handlers">Exceptions in Haskell handlers</h1>
<p>There is no way to catch exceptions in <em>pure</em> handlers. However they can arise from using <em>partial</em> functions such as <em>head</em> and <em>tail</em>! Switching to their <em>total</em> counterparts from module <em>Safe</em> can mitigate this issue, but it is not possible to eliminate it completely.</p>
<p>Fortunately, all exceptions, synchronous and asynchronous, are caught on top of the module’s Haskell code. If a handler does not catch an exception itself, the exception gets caught higher and logged by Nginx. However, using exception handlers in Haskell handlers, when it’s possible, should be preferred.</p>
<h1 id="summary-table-of-all-nginx-directives-of-the-module">Summary table of all Nginx directives of the module</h1>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 14%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Directive</th>
<th style="text-align: left;">Level</th>
<th style="text-align: left;">Comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>haskell compile</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Compile Haskell code from the last argument. Accepts arguments <em>threaded</em> (use <em>threaded</em> RTS library) and <em>standalone</em> (use <em>standalone</em> approach).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell load</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Load specified Haskell library.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell ghc_extra_options</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Specify extra options for GHC when the library compiles.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell rts_options</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Specify options for Haskell RTS.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell program_options</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Specify program options. This is just another way for passing data into Haskell handlers.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_run</code></td>
<td style="text-align: left;"><code>server</code>, <code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Run a synchronous Haskell task.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell_run_async</code></td>
<td style="text-align: left;"><code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Run an asynchronous Haskell task.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_run_async_on_request_body</code></td>
<td style="text-align: left;"><code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Run an asynchronous Haskell request body handler.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell_run_service</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Run a Haskell service.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_service_var_update_callback</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Declare a callback on a service variable’s update.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell_content</code></td>
<td style="text-align: left;"><code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Declare a Haskell content handler.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_static_content</code></td>
<td style="text-align: left;"><code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Declare a static Haskell content handler.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell_unsafe_content</code></td>
<td style="text-align: left;"><code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Declare an unsafe Haskell content handler.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_async_content</code></td>
<td style="text-align: left;"><code>location</code>, <code>location if</code></td>
<td style="text-align: left;">Declare an asynchronous Haskell content handler.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell_var_nocacheable</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">All variables in the list become no cacheable and safe for using in ad-hoc iterations over <em>error_page</em> cycles.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_var_compensate_uri_changes</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">All variables in the list allow to cheat <em>error_page</em> when used in its redirections and make the cycle infinite.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>haskell_service_var_ignore_empty</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Do not write the service result when its value is empty.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>haskell_service_var_in_shm</code></td>
<td style="text-align: left;"><code>http</code></td>
<td style="text-align: left;">Store the service result in a shared memory. Implicitly declares a shared service.</td>
</tr>
</tbody>
</table>
</body>
</html>
